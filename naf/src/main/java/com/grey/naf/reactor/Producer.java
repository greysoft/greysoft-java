/*
 * Copyright 2011-2012 Yusef Badri - All rights reserved.
 * NAF is distributed under the terms of the GNU Affero General Public License, Version 3 (AGPLv3).
 */
package com.grey.naf.reactor;

/*
 * This class allows the Dispatcher thread to act as a consumer of events generated by an external Producer
 * which may well be running in a different thread (hence the Dispatcher thread is also known as the
 * Consumer thread).
 * Although this class is called Producer, it is owned by the Dispatcher and the actual producer is the
 * external entity who calls its produce() methods. So it is a Producer from the point of view of the
 * Dispatcher (which is its consumer) rather than a mechanism by which the Dispatcher acts as a consumer.
 */
public class Producer<T>
{
	public interface Consumer
	{
		void producerIndication(Producer<?> p) throws com.grey.base.FaultException, java.io.IOException;
	}

	public final String consumerType;
	private final com.grey.base.utils.Circulist<T> exchgq;  // exchange items with producer thread
	private final com.grey.base.utils.Circulist<T> availq;  // this is only accessed by the consumer thread
	private final AlertsPipe alertspipe;
	private final com.grey.base.utils.GenericIterator<T> synciter = new com.grey.base.utils.GenericIterator<T>();
	private final org.slf4j.Logger logger;
	private Consumer consumer;

	public Producer(Class<?> clss, Dispatcher dsptch, Consumer cons)
			throws com.grey.base.ConfigException, com.grey.base.FaultException, java.io.IOException
	{
		this(clss, dsptch, cons, null);
	}

	public Producer(Class<?> clss, Consumer cons, org.slf4j.Logger log)
			throws com.grey.base.ConfigException, com.grey.base.FaultException, java.io.IOException
	{
		this(clss, null, cons, log);
	}

	private Producer(Class<?> clss, Dispatcher dsptch, Consumer cons, org.slf4j.Logger log)
			throws com.grey.base.ConfigException, com.grey.base.FaultException, java.io.IOException
	{
		if (log == null && dsptch != null) log = dsptch.logger;
		logger = log;
		consumerType = cons.getClass().getName()+"/"+clss.getName();
		alertspipe = (dsptch == null ? null : new AlertsPipe(dsptch, this));
		consumer = cons;
		exchgq = new com.grey.base.utils.Circulist<T>(clss);
		availq = new com.grey.base.utils.Circulist<T>(clss);
		if (logger != null) logger.debug("Dispatcher="+(dsptch==null?"n/a":dsptch.name)+" created Producer="+this
				+" for Consumer="+cons.getClass().getName()+"/"+clss.getName());
	}

	// If some items are already on the available queue, then we don't attempt to consume them even if
	// the 'consume' arg is true, as this shutdown could only be occurring during a notifyConsumer()
	// callout, so the caller has already decided to abort.
	public void shutdown(boolean consume)
	{
		if (consumer == null) return;
		try {
			if (alertspipe != null) alertspipe.shutdown();
		} catch (Exception ex) {
			if (logger != null) logger.info("Error on Producer shutdown", ex);
		}
		int ready = availq.size();
		takePendingItems();
		int pending = availq.size() - ready;

		if (logger != null && availq.size() != 0) logger.info("Shutdown Producer="+this+" with pending="+ready+"/"+pending
				+" - Consumer="+consumer.getClass().getName());
		if (consume && ready == 0 && pending != 0) {
			notifyConsumer();
			if (logger != null) logger.info("Shutdown Producer="+this+": Drainage completed - pending="+availq.size());
		}
		consumer = null;
	}

	public final T consume()
	{
		if (availq.size() == 0) return null;
		return availq.remove();
	}

	// These produce() methods are called by the external producer and are the only methods
	// in this class which might be called by a different thread (ie. not the Dispatcher
	// thread).
	// If exchgq already has unconsumed items on it, then we assume the consumer has already
	// been signalled, so we can skip the I/O cost of sending them a redundant signal.
	public final void produce(T item, Dispatcher d) throws java.io.IOException
	{
		if (consumer == null) {
			throw new java.io.IOException("Illegal put on closed Producer+"+this+" - "+(alertspipe==null?"Sync":alertspipe.dsptch.name));
		}
		if (alertspipe == null || d == alertspipe.dsptch) {
			syncProduce(synciter.reset(item));
		} else {
			int cnt;
			synchronized (exchgq) {
				cnt = exchgq.size();
				exchgq.append(item);
			}
			if (cnt == 0) alertspipe.signalConsumer();
		}
	}

	public final void produce(java.util.ArrayList<T> items, Dispatcher d) throws java.io.IOException
	{
		if (consumer == null) {
			throw new java.io.IOException("Illegal put-list on closed Producer+"+this+" - "+(alertspipe==null?"Sync":alertspipe.dsptch.name));
		}
		if (alertspipe == null || d == alertspipe.dsptch) {
			syncProduce(synciter.reset(items));
		} else {
			int cnt;
			synchronized (exchgq) {
				cnt = exchgq.size();
				for (int idx = 0; idx != items.size(); idx++) {
					exchgq.append(items.get(idx));
				}
			}
			if (cnt == 0) alertspipe.signalConsumer();
		}
	}

	public final void produce(T[] items, int off, int len, Dispatcher d) throws java.io.IOException
	{
		if (consumer == null) {
			throw new java.io.IOException("Illegal put-array on closed Producer+"+this+" - "+(alertspipe==null?"Sync":alertspipe.dsptch.name));
		}
		if (alertspipe == null || d == alertspipe.dsptch) {
			syncProduce(synciter.reset(items, off, len));
		} else {
			int lmt = off + len;
			int cnt;
			synchronized (exchgq) {
				cnt = exchgq.size();
				for (int idx = off; idx != lmt; idx++) {
					exchgq.append(items[idx]);
				}
			}
			if (cnt == 0) alertspipe.signalConsumer();
		}
	}

	public final void produce(T[] items, Dispatcher d) throws java.io.IOException
	{
		produce(items, 0, items.length, d);
	}

	private void syncProduce(com.grey.base.utils.GenericIterator<T> iter)
	{
		while (iter.hasNext()) {
			availq.append(iter.next());
		}
		notifyConsumer();
	}

	private void notifyConsumer()
	{
		int ready = availq.size();
		if (consumer == null || ready == 0) return;
		try {
			consumer.producerIndication(this);
		} catch (Exception ex) {
			if (logger != null) logger.info("Consumer failed to handle Producer-indication - left "+availq.size()+"/"+ready, ex);
		}
	}

	protected void producerEvent()
	{
		takePendingItems();
		notifyConsumer();
	}

	private void takePendingItems()
	{
		synchronized (exchgq) {
			while (exchgq.size() != 0) {
				availq.append(exchgq.remove());
			}
		}
	}


	/*
	 * Encapsulate the ChannelMonitor functionality within a nested class, rather than making it a base class for Producer.
	 * We prefer composition to inheritance, not least because if Producer inherited from ChannelMonitor, it would expose all its methods.
	 * This ChannelMonitor receives I/O indications from the Producer thread(s).
	 * This class is non-private only because Dispatcher.dumpState() needs to be able to see it.
	 */
	protected static final class AlertsPipe
		extends ChannelMonitor
	{
		public final Producer<?> producer;
		private final java.nio.channels.Pipe.SinkChannel wep;  //Write end-point of pipe
		private final java.nio.ByteBuffer xmtbuf;

		AlertsPipe(Dispatcher d, Producer<?> p) throws com.grey.base.ConfigException, com.grey.base.FaultException, java.io.IOException
		{
			super(d);
			producer = p;

			java.nio.channels.Pipe pipe = java.nio.channels.Pipe.open();
			java.nio.channels.Pipe.SourceChannel rep = pipe.source(); //Read end-point
			wep = pipe.sink();
			wep.configureBlocking(false);

			java.nio.ByteBuffer niobuf = com.grey.base.utils.NIOBuffers.create(1, true);
			niobuf.put((byte)1); //value doesn't matter
			xmtbuf = niobuf.asReadOnlyBuffer();

			// enable event notifications on the read (consumer) endpoint of our pipe
			com.grey.naf.BufferSpec bufspec = new com.grey.naf.BufferSpec(64, 0, false);
			chanreader = new com.grey.naf.reactor.IOExecReader(bufspec);
			initChannel(rep, true, true);
			chanreader.receive(0, true);
		}

		void shutdown() throws java.io.IOException
		{
			wep.close();
			disconnect();
		}

		// This is called by Producers outside the Dispatcher thread.
		// We don't care if the write() returns zero because it's blocked. We are not sending data which the
		// consumer has to read, but merely kicking it into action, and if the pipe is full, then the
		// consumer will surely be signalled that I/O is pending.
		void signalConsumer() throws java.io.IOException
		{
			xmtbuf.flip();
			wep.write(xmtbuf);
		}

		// This happens within the Dispatcher (consumer) thread.
		@Override
		public void ioReceived(com.grey.base.utils.ArrayRef<byte[]> data) throws com.grey.base.FaultException, java.io.IOException
		{
			producer.producerEvent();
		}
	}
}
