<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<HEAD>
<TITLE>NAF - Programmer's Guide</TITLE>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/>
<link rel="stylesheet" type="text/css" href="naf.css"/>
</HEAD>
<BODY>

<div class="menu">
<p>
Programmer's Guide<br/>
NAF v2.3.5
</p>
<hr class="mline"/>
<p>
<a href="#overview">1&nbsp;-&nbsp;Overview</a>
</p>
<p>
<a href="#nafcfg">2&nbsp;-&nbsp;naf.xml</a>
</p>
<p>
<a href="#dispatcher">3&nbsp;-&nbsp;Dispatchers</a>
</p>
<p>
<a href="#naflet">4&nbsp;-&nbsp;NAFlets</a>
</p>
<p>
<a href="#nafman">5&nbsp;-&nbsp;NAFMAN</a>
</p>
<p>
<a href="#dnsresolv">6&nbsp;-&nbsp;DNS&nbsp;Resolver</a>
</p>
<p>
<a href="#listener">7&nbsp;-&nbsp;Listeners</a>
</p>
<p>
<a href="#ssl">8&nbsp;-&nbsp;SSL</a>
</p>
<p>
<a href="#logging">9&nbsp;-&nbsp;Logging</a>
</p>
<p>
<a href="#greybase">10&nbsp;-&nbsp;GreyBase</a>
</p>
<p>
<a href="#demo">11&nbsp;-&nbsp;Demo&nbsp;Apps</a>
</p>
<p>
<a href="#launch">12&nbsp;-&nbsp;Running&nbsp;NAF</a>
</p>
<p>
<a href="../../NOTICE.txt">COPYRIGHT</a>
</p>
<p>
<a href="../../LICENCE.txt">LICENCE</a>
</p>
</div>

<div class="page">
<table class="chtitle" width="100%">
<tr><td>
<center>
Network Application Framework
</center>
</td></tr>
</table>

<h2>
<a name="overview">
1 - Overview
</a>
</h2>

<p>
NAF (Network Application Framework) is a Java API that implements an event-driven framework based on the Java JDK's NIO interface.
</p>
<b>Why NAF?</b>
<ul><li>
NAF supports non-blocking I/O operations (sockets and pipes) and timers, enabling extremely large numbers of concurrent connections and high data throughput levels.
</li><li>
NAF provides a lock-free single-threaded execution environment based on the Reactor pattern - parallelism can be provided by adding more Dispatcher threads.
</li><li>
NAF provides seamless support for non-blocking I/O on SSL connections as well.
You can easily create client or server SSL connections, with or without client certificates, and you can start the connection in SSL mode, or negotiate the transition to SSL later.
</li><li>
You can set up your application in an entirely programmatic manner if you wish, but it can also be automatically constructed and launched via the
<span class="pathname">naf.xml</span>
config file, in which you specify the key classes to be instantiated.
</li><li>
NAF provides an extensible web-based GUI, which lets you see snapshots of the registered I/O endpoints and timers in real time.
You can even kill individual connections.
</li><li>
NAF provides object reuse and minimises memory churn (ie. garbage generation), thus minimising the need for expensive GC (Garbage Collector) runs.
</li></ul>
<p>
NAF is intended to be easy to use and does not provide gratuitous layers of abstraction (which force you to learn excessively large custom APIs) over the familiar JDK interfaces that already do what most people need.
<br/>
What it does, is turn the raw NIO Selector and Channel interfaces into a functioning multiplexor based on the Reactor comms pattern, that performs the I/O ops for you, calls your code with the received data, and then gets out of the way to let your application handle the event.
<br/> <br/>
NAF transparently handles non-blocking writes as you would expect, lets you schedule an unlimited number of arbitrary timed ops (and cancel or reschedule them before they trigger) as you would hope and also lets you specify whether reads should return after a fixed number of bytes, on receipt of a marker char (eg. a LineFeed) or just as soon as any data is available.
<br/> <br/>
NAF also provides the possibly unique feature of a non-blocking DNS resolver, which lets you perform hostname lookups, reverse-IP (PTR) lookups and MX (mailserver) lookups.
<br/> <br/>
In more detail, a NAF application (more precisely termed a "NAFlet", or sometimes a "NAF task") executes under the control of a single-threaded object called a <dfn>Dispatcher</dfn>, which acts as an NIO controller and invokes registered callbacks in your application, as triggered by I/O, Timer and DNS events.
<br/>
As well as simplifying the code, the single-threaded reactor mode of operation permits many optimisations, not least of which is pre-allocating many of the temporary objects that your code might require, so as to reduce memory churn for the GC.
</p>

<hr width="40%"/>
<p>
An overview of the main NAF components follows.
<br/>
To find code-level documentation, you are urged to go to the example programs (see section &sect;11 below), along with the API Reference (which is included in the NAF download), and of course the source code itself, which is freely available.
</p>

<hr class="pline"/>
<h2>
<a name="nafcfg">
2 - NAF Config (naf.xml)
</a>
</h2>

<p>
NAF applications are config-driven, and are specified in an XML-based configuration file which is generically referred to as the
<span class="pathname">naf.xml</span>
file (though it is not necessarily named that).
<br/>
This config file defines the application's Dispatchers and provides a mechanism for automatically wiring in and launching all your application code without you having to provide the <span class="compcode">main()</span> method (<em>and</em> without the use of custom annotations).
<br/>
The top-level structure of a naf.xml file is outlined below (and the binary NAF distribution also contains working naf.xml files for the
<span class="softname">portfwd</span>
sample program and the DNS batch-resolver app embedded in NAF).
</p>

<table class="cfgbox">
<tr><td>
<pre>
&lt;naf&gt;
    &lt;dirpaths&gt;
        &lt;root&gt;.&lt;root&gt;
        &lt;config&gt;%DIRTOP%/conf&lt;config&gt;
        &lt;var&gt;%DIRTOP%/var&lt;var&gt;
        &lt;logs&gt;%DIRVAR%/logs&lt;logs&gt;
        &lt;tmp&gt;%DIRVAR%/tmp&lt;tmp&gt;
    &lt;/dirpaths&gt;
    &lt;baseport&gt;13000&lt;/baseport&gt;
    &lt;dependjars&gt;app1.jar : app2.jar&lt;/dependjars&gt;
    &lt;nafman&gt;
        ...
    &lt;/nafman&gt;
    &lt;dnsresolver&gt;
        ...
    &lt;/dnsresolver&gt;
    &lt;dispatchers&gt;
        ...
    &lt;/dispatchers&gt;
&lt;/naf&gt;
</pre>
</td></tr>
</table>

<p>
The naf.xml header config elements are as follows:
</p>

<p><span class="cfgtitle">dirpaths</span><br/>
This section defines directory paths that a typical NAF application might use. The entire section is optional, since all the paths have default values that are as explicitly defined above.
<br/>
For each path, there is an associated system-property that is looked up if the naf.xml config element is absent, and the default value kicks in if the system property isn't defined either.
<br/>
Thereafter, the value of the path is used to substitute token strings to generate a concrete path.
<br/> <br/>
The use of some replacement tokens is illustrated above.
These substitutions are automatically performed on all
<span class="pathname">naf.xml</span>
paths, and applications can also dynamically perform them on arbitrary strings by calling
<span class="compcode">com.grey.naf.Config.getPath(String path, Class<?> clss)</span>
(the <span class="compcode">clss</span> param is typically null).
<br/> <br/>
The matrix of configuration settings for these paths is specified in the table below:

<table border="1" width="80%">
<tr><th>
	Config Element
	</th><th>
	System Property
	</th><th>
	Default Value
	</th><th>
	Replacement Token
</th></tr>
<tr align="center"><td>
	root
	</td><td>
	greynaf.paths.root
	</td><td>
	<b>.</b><br/>(current directory)
	</td><td>
	%DIRTOP%
</td></tr>
<tr align="center"><td>
	config
	</td><td>
	greynaf.paths.conf
	</td><td>
	./conf
	</td><td>
	%DIRCONF%
</td></tr>
<tr align="center"><td>
	var
	</td><td>
	greynaf.paths.var
	</td><td>
	./var
	</td><td>
	%DIRVAR%
</td></tr>
<tr align="center"><td>
	logs
	</td><td>
	grey.logger.dir
	</td><td>
	./var/logs
	</td><td>
	%DIRLOG%
</td></tr>
<tr align="center"><td>
	tmp
	</td><td>
	grey.paths.tmp
	</td><td>
	./var/tmp
	</td><td>
	%DIRTMP%
</td></tr>
</table>

<p>
The paths are actually defined in terms of each other, so the full derivation is as shown in the naf.xml listing above, and the defaults in the above table are what would result if no config items or system properties are defined.
<br/> <br/>
If the <span class="cfgname">grey.paths.tmp</span> system property is set, then NAF's temp path will default to the global value specified by
<span class="compcode">com.grey.base.config.SysProps.TMPDIR</span>, else it will diverge.
It's up to the application which setting it wishes to abide by.
<br/>
If the 
<span class="cfgname">grey.logger.dir</span> system property is not set, then NAF will set it to the resolved value of its
<span class="cfgname">dirpaths/logs</span> config item, and this ought to propagate to the underlying
<span class="softname">GreyLog</span> logger, so long as you loaded naf.xml before creating any loggers.
</p>

<p>
<span class="cfgtitle">baseport</span><br/>
This optional setting specifies the base port number above which NAF applications allocate the range of TCP ports they may use - whether purely internally or advertised externally.
The actual number of reserved TCP ports depends on the NAF application, but it will be a contiguous block starting this base port.
<br/>
If this config item is absent, the setting is obtained from the
<span class="cfgname">greynaf.baseport</span>
system property, and if that is also absent, the ultimate default is 13000.
</p>

<p> <span class="cfgtitle">dependjars</span><br/>
A colon-separated list of dependent JAR files to dynamically load.
<br/>
Some of the list items may be directory paths rather than a JAR pathname, and if so, then:<br/>
- If directory spec ends in / (forward slash): NAF loads any .jar files found in that directory.<br/>
- Else, the directory itself is placed on the live classpath.
<br/> <br/>
Note that the
<span class="cfgname">greynaf.cp</span>
system property can be used as an alternative to the
<span class="cfgname">dependjars</span>
config element.
<br/>
Their syntax and treatment is identical, but the system property is evaluated a fraction earlier during application startup.
<br/>
It is a matter of personal preference as to whether you would prefer to specify extra JARs in the naf.xml file or via system properties.
</p>

<hr class="pline"/>
<h2>
<a name="dispatcher">
3 - Dispatchers
</a>
</h2>

<p>
Dispatchers are the event multiplexers at the heart of the NAF framework, and each dispatcher resides in its own thread.
Multiple Dispatchers can exist within one JVM process, and they are completely independent of each other.
In a widely used terminology, each Dispatcher represents an event loop.
<br/>
Users can simply regard a Dispatchers as a single-threaded execution context within which their applications reside.
Dispatchers monitor all events (eg. I/O) in which their applications have registered an interest, and they also provide built-in services such as DNS resolution, NAFMAN and logging.
<br/> <br/>
An illustrative
<span class="cfgname">dispatchers</span>
config block is shown below, and as can be seen, each individual
<span class="cfgname">dispatcher</span>
section consists of nothing more than one or more NAFlets, and a set of attributes controlling the dispatcher's own behaviour.
<br/>
The top-level config outlined in section &sect;2 above shows where this block fits into the overall naf.xml config file.
</p>

<table class="cfgbox">
<tr><td>
<pre>
&lt;dispatchers&gt;
    &lt;dispatcher name="dispatcher1"&gt;
        &lt;naflets&gt;
            &lt;naflet name="naflet1a" class="com.my.package.Task1a"&gt;
                ...
            &lt;/naflet&gt;
            &lt;naflet name="naflet1b" class="com.my.package2.Task1b"&gt;
                ...
            &lt;/naflet&gt;
        &lt;/naflets&gt;
    &lt;/dispatcher&gt;

    &lt;dispatcher name="dispatcher2"&gt;
        &lt;naflets&gt;
            &lt;naflet name="naflet2" class="com.my.package2.Task2"&gt;
                &lt;configfile root="xpath"&gt;%DIRCONF%naflet2.xml&lt;/configfile&gt;
            &lt;/naflet&gt;
        &lt;/naflets&gt;
    &lt;/dispatcher&gt;
&lt;/dispatchers&gt;
</pre>
</td></tr>
</table>

<p>
The config block above illustrates the Dispatcher
<span class="cfgtitle">name</span>
attribute, and a description of all the other Dispatcher attributes (specified in same manner) follows.
<br/>
The <span class="compcode">com.grey.naf.DispatcherDef</span> class is where these attributes are parsed, so refer to the source for the full details.
</p>

<ul>
<li><span class="cfgtitle">dns</span>:
Boolean attribute which specifies whether a DNS Resolver will be installed in this Dispatcher.
Default is No.
<br/>
If any of the Dispatcher's installed NAFlets does use the DNS Resolver and this is set to No, then the application will simply crash, so this attribute can be seen as a way of declaring whether this Dispatcher contains any DNS users.
</li>

<li><span class="cfgtitle">enabled</span>:
A boolean attribute which defaults to Yes, but can be set to No to disable a dispatcher (may sometimes be preferable to removing it from the naf.xml file for good).
</li>

<li><span class="cfgtitle">flush</span>:
enabled is a time span, and indicates how often registered flushable objects should be flushed.<br/>
The default is 0, meaning never.
<br/>
A "flushable" object is any object which implements the
<span class="compcode">java.io.Flushable</span>
interface and has been passed to the
<span class="compcode">Dispatcher.flusher.register()</span>
method in order to be periodically flushed, and it is typically a logger or similiar.
<br/>
The rationale behind this facility is that a buffered log file might not get flushed for an indefinite period if no further log messages were written to it, so this attribute guarantees a maximum interval before the last log message is visible in the log file.
</li>

<li><span class="cfgtitle">nafman</span>:
Boolean attribute which specifies whether a NAFMAN agent will be activated in this Dispatcher.
Default is Yes.
<br/>
Beware that turning NAFMAN off will (at the very least) often leave you with no graceful way of shutting down a NAF application.
</li>

<li><span class="cfgtitle">name</span>:
A unique per-Dispatcher tag, which used to specify the name of the GreyLog logger this Dispatcher should create.
<br/>
The <span class="cfgname">greynaf.dispatchers.logname</span> system property overrides that latter function, and specifies a universal logger name for all Dispatchers.
This may be more convenient when the number of Dispatchers is very large (eg. an <span class="softname">EchoBot</span> bulk test).
</li>

<li><span class="cfgtitle">survive_downstream</span>:
Boolean attribute which specifies whether the primary Dispatcher (as the Dispatcher which hosts the primary NAFMAN agent is termed) should survive the death or termination of any secondary Dispatchers.
<br/>
Default is Yes.
</li>

<li><span class="cfgtitle">survive_handlers</span>:
Boolean attribute which specifies whether the Dispatcher should survive errors in any of its registered I/O or Timer handlers.
Default is Yes.
<br/>
Such an "error" is said to have occurred if any callback code throws an Exception back to the Dispatcher.
</li>

<li><span class="cfgtitle">zero_naflets</span>:
Boolean attribute which specifies whether the Dispatcher should terminate when the count of active NAFlets drops to zero.
Default is Yes.
</li>
</ul>

<p>
As explained in the Overview section (see EchoBot), Dispatchers can be either be specified in a naf.xml file, in which case the NAF launcher automatically creates and runs them, or they can be programmatically created and started.
<br/>
The latter are termed dynamic (or programmatically created) Dispatchers, as opposed to the configured ones created via naf.xml.
The distinction is in their startup mode, and once launched, there is no difference in the resulting Dispatchers.
<br/>
Dispatchers are dynamically created by either of these static methods:<br/>
&bull; <span class="compcode">com.grey.naf.Dispatcher.create(com.grey.naf.DispatcherDef, com.grey.naf.Config, com.grey.logging.Logger)</span>
<br/>
&bull; <span class="compcode">com.grey.naf.Dispatcher.create(com.grey.naf.DispatcherDef, int baseport, com.grey.logging.Logger)</span>
<br/>
Once they have been created and set up, you simply call their
<span class="compcode">start()</span>
method.
</p>

<hr class="pline"/>
<h2>
<a name="naflet">
4 - NAFlets
</a>
</h2>

<p>
Each NAF dispatcher executes one or more application entities, known as
<dfn>NAFlets</dfn>.
Whereas Dispatchers are event managers which NAF provides for you, NAFlets embody application-specific functionality which you have to code.
<br/>
Naflets are independent processing tasks which are unaware of other Naflets executing within the same dispatcher, and can be freely moved between dispatchers, according to performance-tuning considerations.
<br/> <br/>
When we say that NAF is a single-threaded framework, what we really mean is that individual NAFlets execute in a single-threaded context (ie. the Dispatcher).
However, real-world applications may comprise multiple NAFlets, which in turn may or may not be distributed over multiple Dispatchers (ie. multiple threads).
The important point is that the Dispatchers are independent of one another and co-exist without incurring any synchronisation overhead, it's ultimately up to the developer how closely coupled their own bespoke NAFlets are, and whether they require synchronisation across multiple threads.
</p>

<p>
The NAFlet config block is illustrated in the Dispatchers section above, and there are 3 top-level attributes.
</p>

<ul>
<li><span class="cfgtitle">class</span>:
This defines the NAFlet's type, and is used by the Dispatcher to instantiate it.
<br/>
All NAFlets are required to be a subclass of <span class="compcode">com.grey.naf.Naflet</span>, so see its source code for further requirements in terms of constructor signature and abstract/override methods.
</li>

<li><span class="cfgtitle">enabled</span>:
A boolean attribute which defaults to Yes, but can be set to No to disable a Naflet (may sometimes be preferable to removing it from the naf.xml file for good).
</li>

<li><span class="cfgtitle">name</span>:
An arbitrary tag, which merely serves to label log messages.
</li>
</ul>

<p>
The inner elements of a
<span class="cfgname">naflet</span>
block are application-specific and are parsed by the bespoke NAFlet code, but there is one generic setting which is understood and actioned by the NAF core:
</p>
<ul>
<li><span class="cfgtitle">configfile</span>:
This specifies an external config file from which this Naflet will read its settings, and the optional
<span class="cfgtitle">root</span>
attribute specifies the relevant section within that config file, in XPath notation.
<br/>
If the
<span class="cfgname">configfile</span>
element is present, then any other elements are ignored, as the configuration is redirected to the indicated external location.
</li>
</ul>

There are two ways a NAFlet can be loaded into a NAF process:
<ul><li>
One way is to define it in a naf.xml config file as described above, and that will take care of automatically instantiating and run them when NAF starts up.
</li><li>
The other way, is to programmatically create the NAFlet object, and then pass it to a running Dispatcher by calling its
<span class="compcode">loadNaflet(com.grey.naf.Naflet, com.grey.naf.Dispatcher)</span>
method.
</li></ul>
<p>
The Dispatcher will call the NAFlet's
<span class="compcode">start()</span>
method from within its own thread (so it must not have been called already) and the NAFlet would then be live.
This method can be used to load new NAFlets whether the Dispatcher was originally launched from a naf.xml file or programmatically.
<br/>
The Dispatcher argument indicates which Dispatcher the calling code is associated with, and would be set to Null if it's not running within a Dispatcher.
If you are calling loadNaflet() on a Dispatcher which you have just created programmatically but not yet started, then you should pass in <span class="compcode">null</span> as the Dispatcher reference, and it will load the NAFlet once it starts up.
<br/> <br/>
There is also an
<span class="compcode">unloadNaflet(String naflet_name, com.grey.naf.Dispatcher)</span>
method, which tells the Dispatcher to stop the NAFlet of that name, if it's running.
</p>

<hr class="pline"/>
<h2>
<a name="nafman">
5 - NAFMAN
</a>
</h2>

<p>
NAFMAN is the NAF management agent. It is web-enabled, and enables you to issue commands to a running NAF application from your browser or the command line.
<br/>
A NAFMAN agent is embedded in every dispatcher by default, and the first NAFMAN-enabled Dispatcher becomes the Primary NAFMAN agent, all the others (if any) becoming its Secondaries.
<br/> <br/>
The
<span class="cfgname">nafman</span>
config block is typically absent from the
<span class="pathname">naf.xml</span>
config file,
but that does not mean NAFMAN is disabled, merely that it's operating with its default settings.
NAFMAN can only be disabled on a per-Dispatcher basis, via the Dispatcher's
<span class="cfgname">nafman</span>
attribute.
<br/>
The structure of the config block is illustrated below, but you should rarely need to modify it as they are more a case of low-level tuning than anything else.
<br/>
See the
<span class="compcode">com.grey.naf.nafman.Server</span>
source code for all the options - plus the usual Listener attributes.
</p>
<table class="cfgbox">
<tr><td>
<pre>
&lt;nafman&gt;
    &lt;listener&gt;
        &lt;server&gt;
            ... see NAFMAN source ...
        &lt;/server&gt;
    &lt;/listener&gt;
&lt;/nafman&gt;
</pre>
</td></tr>
</table>
<p>
The most likely option you would want to change is the TCP port on which the NAFMAN server listens, which by default is the same as the
<span class="cfgname">baseport</span> (see &sect;2 above), ie. 13000.
<br/>
However, if you do want to change this port, it should be done via the
<span class="cfgname">baseport</span>
config setting, NOT the Listener's
<span class="cfgname">port</span>
attribute.
That way, NAF continues to reserve a contiguous block of ports that is specified in one place.
<br/> <br/>
The upshot of the above is that (notwithstanding any changes to the
<span class="cfgname">baseport</span>)
if you point your browser at port 13000, you will see the NAFMAN home page, where you can issue various NAFMAN commands and navigate to other screens.
<br/>
NAF contains a built-in NAFMAN home page called the
<span class="softname">NAF Dashboard</span>,
but this can be overridden by NAF-based applications (eg.
<span class="softname">Mailismus</span>
installs its own bespoke home page).
<br/> <br/>
NAFMAN's capabilities are best understood by viewing it on your browser, but the available control points include stopping NAF as a whole, or stopping individual Dispatchers or NAFlets, as well as monitoring the state of all the Dispatchers (you can view all current I/O channels/connections and timers - and even kill TCP connections).
<br/>
Assorted other NAF and application commands are also available, as well as the ability to inspect NAFMAN's own internal state, eg. which components have registered to handle which commands.
<br/>
Since NAFMAN command handlers are dynamically registered, the exact set of commands available will depend on your Dispatcher config and active NAFlets.

<br/> <br/>
NAFMAN commands can also issued from the command line, by entering the Path and Query-String part of the URL (ie. the URL mimnus the host-port part) as the argument to the NAF Launcher's
<span class="cfgvalue">-cmd</span>
option
<br/>
For example, the following command-line invocations list all the available NAFMAN commands.
The second form illustrates how to connect to an arbitrary instance of NAFMAN, rather than the one associated with a particular naf.xml file.
</p>
<div>
<span class="vt220">
java -jar lib/greynaf-2.3.5.jar -c conf/naf.xml -cmd showconns?nohttp=y&nbsp;
<br/><br/><br/>
&nbsp;java -jar lib/greynaf-2.3.5.jar -remote hostname:13000 -cmd showconns?nohttp=y
</span>
</div>
<p>
As a web-based agent, NAFMAN returns a standard HTTP response even when invoked from the command line (in fact internally, this issues a HTTP request and forwards the response) and the body of the response is in general an XML document (although even that depends on the particular handler for that command).
<br/>
Some of the more common NAFMAN options are:
</p>
<ul>
<li><span class="cfgname">d</span>: Dispatcher name - 
This targets the command at a particular Dispatcher.
Some commands are applicable to all Dispatchers, unless thus filtered.
</li><li><span class="cfgname">n</span>: NAFlet name - 
This targets the command at a particular NAFlet.
</li><li><span class="cfgname">st</span>: Stylesheet name (this is a hard-coded auto-registered name)
</li><li><span class="cfgname">nohttp</span>: Omit header from HTTP response<br/>
This might be useful in command-line mode, if you want to pipe the XML response into your own XSL stylesheet.
</li>
</ul>
<p>
Putting it all together, the following command-line invocation can be used to terminate a named NAFlet within a named Dispatcher.
<br/>
(NB: On a Unix platform, you will need to escape the ampersand using the usual Shell syntax)
</p>
<div>
<span class="vt220">
java -jar lib/greynaf-2.3.5.jar -remote hostname:13000 -cmd appstop?d=dispname&amp;n=appname
</span>
</div>
<p>
See section &sect;12 below for more general info on command-line usage.
</p>

<hr class="pline"/>
<h2>
<a name="dnsresolv">
6 - DNS Resolver
</a>
</h2>

<p>
The DNS Resolver offers a simple non-blocking API to NAF components, and supports A (hostname), MX (email domain) and PTR (reverse lookup on IP addresses) lookups.
<br/>
It issues DNS queries to the nominated DNS servers,and calls back to your application code with the answers.
The resolver caches the results so that future lookups on the same domain can be satisfied internally within NAF, without recourse to any more external queries.
It also caches negative answers (ie. domain name not found).

<br/> <br/>
NAF offers two alternative implementations of the DNS Resolver, namely the Embedded Resolver and the Distributed Resolver.
</p>
<ul>
<li>
The Embedded resolver effectively represents an independent resolver within each Dispatcher, each with its own results cache.
<br/>
DNS users within a Dispatcher enjoy direct lock-free I/O-free access to its DNS cache.
</li><li>
The Distributed resolver is implemented as master and secondary parts, where the master component resides in one DNS-enabled Dispatcher, and all other DNS-enabled Dispatchers take on the secondary role.
<br/>
What this means is that only one DNS cache exists and it is owned by the master resolver (which is essentially identical to the Embedded Resolver). The secondary resolvers incur a slight processing overhead in accessing it.
<br/>
For performance reasons therefore, if one of the Dispatchers is expected to be a heavier DNS user than the others, we recommend it takes on the master role, as it will have faster access to the DNS cache.
<br/>
The master and secondary roles in the distributed resolver are sometimes referred to as server and client, but they are all "clients" to the core resolver service.
</li>
</ul>
<p>
So the trade-off between the EmbeddedResolver and the distributed clients is one of speed versus memory consumption, though the secondary distributed resolvers are still likely to be more than fast enough for most uses, and we recommend the distributed resolver if the DNS cache is expected to grow to a significant size.
<br/> <br/>
Note that the difference between the embedded and distributed resolvers, as well as the division of responsibility between the roles of the distributed resolver is internal to the DNS resolver, and user code within each Dispatcher accesses the resolver via a single API, represented by the
<span class="compcode">com.grey.naf.dns.Resolver</span>
class (see the
<span class="compcode">Dispatcher.dnsresolv</span>
field) and its
<span class="compcode">Resolver.Client</span>
callback interface.
User code is unaware what underlying type of DNS resolver it is calling, and it has no effect on the final answer.

<br/> <br/>
Each dispatcher may contain its own asynchronous (non-blocking) DNS resolver
(see their
<span class="cfgname">dns</span>
attribute), but they're all controlled by one
<span class="cfgname">dnsresolver</span>
config block at the top level of the naf.xml file.
<br/>
This config block consists entirely of optional parameters, and may be absent from the config file if you don't want to modify its defaults, but its absence simply means that those defaults will be in effect, not that DNS lookup is disabled.
A resolver will still be created in all dispatchers that have their
<span class="cfgname">dns</span>
attribute set to Yes.
<br/> <br/>
Selected DNS config attributes are shown below.<br/>
See the source of the <span class="compcode">com.grey.naf.dns.ResolverService</span> class for the full list
</p>

<table class="cfgbox">
<tr><td>
<pre>
&lt;dnsresolver class="com.grey.naf.dns.distributedresolver.Client" master="name" alwaystcp="N"&gt;
    &lt;servers&gt;192.168.1.1 | 192.168.1.2&lt;/servers&gt;
    &lt;query_mx fallback_a="N" maxrr="5"&gt;
    &lt;cache negttl="1h" exitdump="N"&gt;
&lt;/dnsresolver&gt;
</pre>
</td></tr>
</table>

<ul>
<li><span class="cfgtitle">class</span>:
NAF contains two alternative DNS resolvers.
<br/>
The default is
<span class="compcode">com.grey.naf.dns.embedded.EmbeddedResolver</span>,
for the embedded resolver, while the example above shows the class to use for the distributed resolver.
<br/>
As explained above, these are plug-in alternatives which represent architectural choices, but are transparent to your code.
</li>

<li><span class="cfgtitle">master</span>:
This optional attribute only applies to the distributed resolver, and specifies the name of the Dispatcher which will take on the master role.
<br/>
If absent, the first DNS-enabled Dispatcher in the naf.xml config file becomes the master resolver.
</li>

<li><span class="cfgtitle">servers</span>:
This is the DNS parameter you're most likely to alter, and it specifies one or more local DNS servers (as hostnames or dotted IPs) which offer full recursive resolution.
<br/>
If absent, NAF will automatically obtain the DNS servers configured into the underlying OS (see
<span class="pathname">/etc/resolv.conf</span>
on Unix, or TCP Properties on Windows), and in the unlikely event that turns up blank, it will use localhost (127.0.0.1).
<br/>
If NAF has multiple DNS servers available to it, it will round-robin DNS requests between them, which is desirable at times of high loading.
</li>

<li><span class="cfgtitle">alwaystcp</span>:
Use TCP mode exclusively, rather than merely falling back to it when we received a truncated DNS reply.
<br/>
Default is No.
</li>

<li><span class="cfgtitle">fallback_a</span>:
This enables what is known as the "Implicit MX" rule, whereby if an email domain has no MX RRs, we fall back to requesting the corresponding A RR.
<br/>
The Implicit MX rule has been mandated by the SMTP standards ever since RFC 821 was first published in 1982, but the NAF resolver defaults this setting to No on the grounds that it's very unlikely a valid email domain of today would rely on it.
To formally conform to the standard, you need to intervene and set this to Yes.
</li>

<li><span class="cfgtitle">maxrr</span>:
All email domains specify one or more MX relays that serve them, and NAF caches the corresponding DNS RRs (Resource Records).
<br/>
This lets you limit how many of RRs to cache per MX domain.
<br/>
The defaults is 5. Set to zero for no limit.
</li>

<li><span class="cfgtitle">negttl</span>:
NAF caches negative (RR doesn't exist) responses as well as positive, and this specifies the TTL (Time To Live) to apply to negative cache entries.<br/>
Default is 1h (1 hour).
</li>

<li><span class="cfgtitle">exitdump</span>:
Boolean attribute which default to No.
<br/>
If Yes, then the DNS Resolver will dump its cache (somewhere under the
<span class="pathname">var</span>
directory - see
<span class="cfgname">dirpaths</span>
settings above) on exit.
</li>
</ul>

<hr class="pline"/>
<h2>
<a name="listener">
7 - Listeners
</a>
</h2>

<p>
The Listener is a generic NAF component that crops up in many scenarios.
It is a functional building block that allows you to listen on a specified TCP port and serve incoming connections with a specified server class.
<br/>
It can be created either programmatically or by a naf.xml config file.
While the programmatic mode allows you to create concurrent or iterative servers, the config mode only supports concurrent.
<br/> <br/>
The Listener config block can be specified in arbitrary locations within the NAFlet config, and takes the form shown below:
</p>

<table class="cfgbox">
<tr><td>
<pre>
&lt;listener name="webserver" port="80" interface="127.0.0.1"
          maxservers="1000" backlog="100"&gt;
    &lt;ssl ... /&gt;
    &lt;server class="com.grey.http.Server"&gt;
        ...
    &lt;/server&gt;
&lt;/listener&gt;
</pre>
</td></tr>
</table>

<p>
The Listener's attributes are as follows:
</p>

<ul>
<li><span class="cfgtitle">name</span>:
An arbitrary tag, which mainly serves to label log messages, but also supports the
<span class="compcode">getByName(String name)</span>
static Listener method.
<br/>
This is an optional attribute which must be unique if specified.
If omitted, a unique tag will be auto-generated.
</li>

<li><span class="cfgtitle">port</span>:
The TCP port to listen on.
<br/>
The controlling application can programmatically set an appropriate default value, in which case this becomes optional.
</li>

<li><span class="cfgtitle">interface</span>:
The interface to listen on, specified as either a hostname or a dotted IP address.
<br/>
Defaults to all IP interfaces.
</li>

<li><span class="cfgtitle">maxservers</span>:
This sets an upper limit on the number of concurrent server connections.
If this is reached, subsequent connections will be refused.
<br/>
The default is no limit.
</li>

<li><span class="cfgtitle">backlog</span>:
This is a socket-level OS parameter, which controls how many pending connections the underlying OS will accept and hold in a pending queue, if they arrive faster than they can be passed up to the NAF application.
<br/>
The default is 1000.
</li>

<li><span class="cfgtitle">ssl</span>:
This is an optional config block which adds SSL functionality. See &sect;8 below.
</li>
</ul>

<p>
The contents of the
<span class="cfgname">server</span>
config block depend on the particular server, but it's top-level attributes are as follows:
</p>

<ul>
<li><span class="cfgtitle">class</span>:
This specifies the class to instantiate as a server, and pass incoming connections on to.
<br/>
It is required to be a subclass of
<span class="compcode">com.grey.naf.reactor.ConcurrentListener.Server</span>,
so see its source code for further requirements in terms of constructor signature and abstract/override methods.
<br/>
Like the Listener's
<span class="cfgtitle">port</span>
this class may be omitted if the controlling application programmatically sets a default.
</ul>

<p>
Note that the Listener does not instantiate a Server for every incoming connection, as it stores server objects on an ObjectWell
(see <span class="compcode">com.grey.base.utils.ObjectWell</span> for reuse, and will soon reach a steady state where it always has spare servers in reserve.
The
<span class="softname">portfwd</span>
example app is a good example of how this works, including the use of the prototype factory.
<br/> <br/>
There is one further variation to consider:
<br/>
Listener config blocks may exist as a sequence, and you may want Listeners on different interfaces or even ports to share the same Server config.
<br/>
This can be achieved by the use of an extra Listener attribute called
<span class="cfgname">configlink</span>, which points at the config block of another named listener, as illustrated below.
</p>

<table class="cfgbox">
<tr><td>
<pre>
&lt;listeners&gt;
    &lt;listener name="webserver" port="80" interface="127.0.0.1"
              iterative="N" backlog="100"&gt;
        &lt;server class="com.grey.http.Server"&gt;
            ...
        &lt;/server&gt;
    &lt;/listener&gt;
    &lt;listener name="webserver_alt" port="8080" interface="127.0.0.1"
              configlink="webserver"/&gt;
&lt;/listeners&gt;
</pre>
</td></tr>
</table>

<p>
The above XML block configures Listener
<span class="cfgname">webserver_alt</span>
on port 8080 to use the same server config as the first Listener on port 80.
</p>

<hr class="pline"/>
<h2>
<a name="ssl">
8 - SSL
</a>
</h2>

<p>
NAF provides full fledged support for SSL connections in non-blocking mode. This includes client and server mode, client certificates, and the ability to switch to SSL after starting a connection (having exchanged unencrypted data).
<br/> <br/>
The
<span class="compcode">com.grey.naf.reactor.SSLConnection</span>
and
<span class="compcode">com.grey.naf.SSLConfig</span>
classes provide the core of the SSL functionality with the latter providing the means to configure the SSL settings. This can be done programatically via the <span class="compcode">SSLConfig.Def</span> class, or via an XML config block which gets parsed into an SSLConfig.def instance - see <span class="compcode">SSLConfig.create()</span>.
<br/> <br/>
A NAF class which engages in a connection is always a subclass of
<span class="compcode">com.grey.naf.reactor.ChannelMonitor</span>
and it tells ChannelMomitor whether it requires an SSL connection by means of the abstract
<span class="compcode">ChannelMonitor.getSSLConfig()</span> method.
<br/>
If you override this method to return a non-null value, then ChannelMonitor will act accordingly and make an SSL connection when you call the
<span class="compcode">ChannelMonitor.connect()</span> method.
<br/>
NAF servers inherit their SSL settings from NAF's built-in Listener, and it's SSL capabilities are also controlled by the same <span class="compcode">SSLConfig</span> class.
<br/> <br/>
The available settings are probably best described by going through the XML config node. It need not necessarily be called "ssl", as it is the attributes that are read by SSLConfig.
</p>

<table class="cfgbox">
<tr><td>
<pre>
&lt;ssl cert="my-cert-id" kspath="keystore-path" certpass="mypass"
    peercert="peer-cert-name" tspath="truststore-path"
    latent="N" mandatory="N"
    clientauth="1"/&gt;
</pre>
</td></tr>
</table>

<ul>
<li><span class="cfgtitle">cert</span><br/>
This indicates that we're going to supply a certificate. The server end of an SSL connection always has to do so, but a client may optionally do so.
<br/>
NAF's certificate handling is based on the
<span class="softname">keytool</span>
utility that comes as part of the Java JDK, and the value of the
<span class="cfgname">cert</span>
attribute is an alias into what keytool calls a <i>key-store</i>, namely a file containing certificates and private keys which are identified by aliases - such as the one specified by this attribute.
</li>

<li><span class="cfgtitle">kspath</span><br/>
If a
<span class="cfgname">cert</span>
attribute was specified, then
<span class="cfgname">kspath</span>
must be as well, and it is the pathname of the aforementioned keystore file.
<br/>
If prefixed with
<span class="cfgvalue">cp:</span>
the pathname will be interpreted as a classpath.
</li>

<li><span class="cfgtitle">certpass</span><br/>
This attribute also goes with
<span class="cfgname">cert</span>
and
<span class="cfgname">kspath</span>
and it is the password required to unlock the certificate within the keystore.
<br/>
NB: Depending how the keystore was constructed, you might need an additional password to unlock it, and that is specified by the
<span class="cfgname">kspass</span>
attribute (not shown).
</li>

<li><span class="cfgtitle">peercert</span><br/>
Whereas the
<span class="cfgname">cert</span>
attribute is used to identify the certificate supplied by this end of the connection, the
<span class="cfgname">peercert</span>
attribute is used to authenticate the other end, and specifies a certificate name to expect.
<br/>
The specified name is matched against the peer certificate's
<span class="softname">subjectAlternativeName</span> DNS-name
attribute if present, else against its
<span class="softname">Common-Name</span>
attribute.
<br/>
Note that the
<span class="cfgname">peercert</span>
attribute tells the <span class="compcode">SSLConnection</span> class to automatically authenticate the peer certificate, and the SSL connection will never get returned to your application if it fails.
If you wish to do alternative forms of authentication, you can always omit the
<span class="cfgname">peercert</span>
setting from your
<span class="compcode">SSLConfig</span> class, and then do the authentication within your own code after the SSL connection has been established, by requesting the peer certificate using the
<span class="compcode">ChannelMonitor.getPeerCertificate()</span> method.
</li>

<li><span class="cfgtitle">tspath</span><br/>
This specifies the pathname of a <i>trust-store</i> file, which controls the authentication of peer certificates.
<br/>
If all the peer certificates (ie. certificates supplied by the other end of the TCP/IP connection, be it a server or a client) you will encounter are signed by a recognised CA (certificate authority), then you have no need of a trust-store, but ad-hoc certificates (ie. self-signed, or signed by an unknown private CA) need to be added to the trust store before they can be accepted.
<br/>
Ad-hoc certificates which are not present in the trust-store will be automatically rejected by Java's internal SSL libraries.
<br/>
Like the above-mentioned key-store, the trust-store is also maintained using Java's
<span class="softname">keytool</span>
utility.
<br/>
If prefixed with
<span class="cfgvalue">cp:</span>
the trust-store pathname will be interpreted as a classpath.
</li>

<li><span class="cfgtitle">clientauth</span><br/>
This is only applicable in server mode, and can be set to 0, 1 or 2, meaning respectively that client certificates will be discarded, accepted or are compulsorily required.
<br/>
If set to 2 and the client does not supply a certificate, then the SSL handshake will be failed by Java's internal SSL libraries, before it even hits NAF or your application code.
<br/>
Setting it to 1 merely tells Java to pass the client certificate up to NAF, and does not prejudge whether or not it subsequently gets authenticated by NAF (based on the
<span class="cfgname">peercert</span>
setting) or your application.
<br/>
This setting defaults to 1.
</li>

<li><span class="cfgtitle">latent</span><br/>
This setting is what enables NAF to establish a non-SSL connection, and then switch to SSL mode afterwards on demand - by calling the
<span class="compcode">ChannelMonitor.startSSL()</span>
method from your application.
<br/>
It is false by default, but if set to true, then a NAF listener will spawn non-SSL servers, and
<span class="compcode">ChannelMonitor.connect()</span>
will create a non-SSL connection.
Of course, the difference between this and a connection which doesn't even have an
<span class="compcode">SSLConfig</span>
instance attached to it, is that we can call <span class="compcode">ChannelMonitor.startSSL()</span> to switch to SSL mode, while the latter cannot.
</li>

<li><span class="cfgtitle">mandatory</span><br/>
This attribute is only relevant if
<span class="cfgname">latent</span>
is false, but NAF does not act on it, and it's interpretation is left up to the application.
<br/>
It typically controls whether the application requires the connection to switch to SSL mode at some stage, or if it's content for it to remain unencrypted over its entire lifetime.
<br/>
It is False by default.
</li>
</ul>

<p>
See the source code for more details, and the
<span class="compcode">SSLConnectionTest</span>
unit test provides an example of how to create SSL clients and servers based on the above settings.
</p>

<hr class="pline"/>
<h2>
<a name="logging">
9 - Logging
</a>
</h2>

<p>
NAF logging is based on the
<span class="softname">GreyLog</span>
logging framework, which is included in the NAF downloads (both source and binary).
<br/>
See the GreyLog
<a href="greylog.htm">Guide</a>
for how to use it.
<br/> <br/>
Each Dispatcher has its own logger, which is made available to its call-out code via the public
<span class="compcode">Dispatcher.logger</span> field.
<br/>
As a developer of NAF applications, your main concern is to provide GreyLog's
<span class="pathname">logging.xml</span>
runtime config file, and NAF will do the rest.

<hr class="pline"/>
<h2>
<a name="greybase">
10 - GreyBase
</a>
</h2>

<p>
<span class="softname">GreyBase</span>
is a term that crops up frequently in the
<span class="softname">NAF</span>
code and comments.
It is a sub-project within NAF and constitutes one of the JAR files in the NAF distribution.
<br/>
Broadly speaking however, NAF is considered to consist of all these JARs (including the logging ones - see &sect;9), not just the one that happens to be called greynaf.jar, so GreyBase is simply a physical subdivision within NAF.
<br/> <br/>
The dividing line between the GreyBase and NAF sub-projects is that NAF is the framework library and can only be used by NAF applications (indeed, using it is what defines a NAF application). GreyBase on the other hand is a utility API, which contains classes that are not intrinsically tied to NAF and can be used by any application in any context.
<br/> <br/>
Notwithstanding that, GreyBase has evolved to serve the needs of NAF applications and will remain focussed on NAF's particular concerns and optimisations,
such as object reuse (see <span class="compcode">ObjectWell</span>),
interpreting byte streams as 8-bit text (a valid assumption for most Internet protocols, including HTTP, FTP &amp; SMTP headers - see <span class="compcode">ByteChars</span>)
and avoiding incidental garbage generation (see <span class="compcode">HashedList</span> and friends).
<br/> <br/>
GreyBase includes the following:<br/>
&bull; SASL: Server and client mode support for Plain, CRAM-MD5 and External<br/>
&bull; Base64 and Hex encoding and decoding<br/>
&bull; Some basic utilities for symmetric and assymetric encryption<br/>
&bull; Hashed maps that support primitives Ints as key or data, without autoboxing to the Integer class<br/>
&bull; Utilities for parsing XML config files
</p>

<hr class="pline"/>
<h2>
<a name="demo">
11 - Demo Apps
</a>
</h2>

<p>
In addition to the source code and Javadoc-generated
<a href="../apidocs/index.html">API Reference</a>,
NAF also provides 3 sample apps (both in pre-built form in the binary download and in source form in the published NAF source tree) that demonstrate its main modes of operation.
<br/>
They also demonstrate how little Java code you need to write, to build relatively complex NAF apps.
</p>

<ul>
<li><span class="softname">Port Forwarder (portfwd)</span>:
This is based on the naf.xml config file (see below).
<br/>
This app also demonstrates the use of NAF timers, configured Listeners and how to implement a NAFlet and create custom NAFMAN commands, but in addition to its primary pedagogic purpose, it is a fully functioning port forwarder, which accepts TCP connections on behalf of backend services and then distributes them to one or more waiting servers.
<br/> <br/>
</li>

<li><span class="softname">Echo Bot</span>:
This demonstrates the alternative means of launching Dispatchers, as it programmatically creates and starts multiple Dispatchers.
<br/>
The EchoBot contains full working examples of how to listen for or initiate TCP connections (with a programmatically created Listener), how to send and receive TCP data once connected, and how to send and receive UDP packets.
<br/> <br/>
</li>

<li><span class="softname">DNS Batch Resolver</span>:
Our third sample app is actually embedded within the NAF code, but is not really part of the library.
It is a standalone NAFlet launched via a provided naf.xml config file
- see the <span class="compcode">com.grey.naf.dns.batchresolver</span> package.
<br/>
This app serves to illustrate NAF's DNS API, and is a fully functioning application which can resolve large numbers of hostnames, IP addresses or MX domains in batch mode. It might be useful for validating large sets of domains.
</li>
</ul>

<hr class="pline"/>
<h2>
<a name="launch">
12 - Running NAF
</a>
</h2>

<p>
When NAF starts up, it loads system properties from a
<dfn>grey.properties</dfn>
file which it looks for it on the following search path:
<br/>
&bull; If the
<span class="cfgname">grey.properties</span> system property
is set, then it specifies the pathname.
<br/>
&bull; <span class="pathname">./grey.properties</span> (ie. look in current directory)
<br/>
&bull; <span class="pathname">$HOME/grey.properties</span>
<br/>
If no <dfn>grey.properties</dfn> file is found or the
<span class="cfgname">grey.properties</span> system property
is set to
<span class="cfgvalue">"-"</span>, then it is simply not loaded. 
<br/>
The file itself is a standard Java properties file, consisting of
<span class="compcode">name=value</span>
lines.

<br/> <br/>
See the source code of the
<span class="compcode">com.grey.naf.Launcher</span>
class, for more detail on the startup processing and options.

<br/> <br/>
The
<span class="softname">portfwd</span>
demo app provides an example of how an application that is based on a <dfn>naf.xml</dfn> config file might pass its
<span class="compcode">main()</span> method directly onto NAF.
<br/>
It's
<span class="compcode">com.grey.portfwd.Task.main()</span>
method does no more than load its own bespoke NAFMAN command, and while this demo app is running, its NAFMAN commands can be accessed either by pointing your browser at the NAFMAN home page (see section &sect;5 above), where the commands are auto-published, or via the command-line as follows:
</p>
<div>
<span class="vt220">
java -jar portfwd-1.0.0.jar -cmd showconns
</span>
</div>

<p>
The
<span class="softname">EchoBot</span>
demo app illustrates the behaviour of an application that doesn't use a naf.xml file, but it still leverages NAF's command-line parsing facilities.
<br/>
As you can see,
<span class="compcode">com.grey.echobot.App</span>
subclasses NAF's
<span class="compcode">com.grey.naf.Launcher</span>
class, and contains the EchoBot's
<span class="compcode">main()</span>
which instantiates the Launcher subclass and then passes control to it.
<br/>
The EchoBot's App class defines a subclass of
<span class="compcode">com.grey.base.utils.CommandParser.OptionsHandler</span>
to define its own command-line options (on top of those understood by NAF), which it loads in its constructor.
<br/>
Because the App class overrides the Launcher's
<span class="compcode">appExec()</span>
method, NAF passes control back to it after parsing the command-line, and the EchoBot takes over from there.

<br/> <br/>
Run NAF directly with the -h option to see its built-in options.
</p>
<div>
<span class="vt220">
java -jar greynaf-2.3.5.jar -h
</span>
</div>

<p>
<br/>
NAF would normally be loaded by your own application rather than executed directly, not least of the reasons being that the application-specific classpath you require will be set in your application's JAR (or enclosing framework), rather than NAF.
<br/>
As noted in section &sect;2 above though, you could specify all the JARs your application requires in the
<span class="cfgname">dependjars</span>
config item or the
<span class="cfgname">greynaf.cp</span>
system property, and if so, you could launch your application by directly executing
<span class="pathname">greynaf.jar</span>

<br/> <br/>
One case where you would execute NAF from its own JAR (and without having to specify any extra JAR dependencies) is when running the
<span class="softname">DNS Batch Resolver</span>,
NAF's sole built-in NAFlet.
<br/>
Assuming you have downloaded and extracted the binary NAF distribution (or built your own and extracted the resulting ZIP/Tar file), you would run it as follows:
</p>
<div>
<span class="vt220">
java -jar lib/greynaf-2.3.5.jar -c conf/batchresolver.xml -logger dnsbatch &lt; infile
</span>
</div>
<p>
The input file should contain one record per line, but the type of the records depends on the batchresolver.xml settings.
<br/>
&bull; <span class="cfgvalue">mode=A</span>:
Hostnames in FQDN (Fully Qualified Domain Name) form
<br/>
&bull; <span class="cfgvalue">mode=PTR</span>:
Dotted IP address
<br/>
&bull; <span class="cfgvalue">mode=MX</span>:
Email domains (mailbox part will be stripped if present)
<br/>
The above command also assumes a
<span class="pathname">logging.xml</span>
GreyLog config file, which contains a logger entry called
<span class="cfgvalue">dnsbatch</span>.
</p>

<br/>&nbsp;<br/>&nbsp;<br/>
</div>
</BODY>
</HTML>
